from __future__ import annotations

from collections.abc import Sequence
from typing import Literal, cast

import numpy as np

import imgaug2.dtypes as iadt
import imgaug2.imgaug as ia
import imgaug2.mlx.color as mlx_color
import imgaug2.parameters as iap
import imgaug2.random as iarandom
from imgaug2.augmentables.batches import _BatchInAugmentation
from imgaug2.augmenters import meta
from imgaug2.augmenters._typing import Array, ChildrenInput, Images, ParamInput, RNGInput
from imgaug2.compat.markers import legacy
from imgaug2.mlx._core import is_mlx_array

from ._utils import (
    CSPACE_HSV,
    CSPACE_RGB,
    ColorSpace,
    PerChannelInput,
    _get_arithmetic,
    _is_mlx_list,
)
from .colorspace import change_colorspace_, change_colorspaces_

class WithHueAndSaturation(meta.Augmenter):
    """
    Apply child augmenters to hue and saturation channels.

    This augmenter takes an image in a source colorspace, converts
    it to HSV, extracts the H (hue) and S (saturation) channels,
    applies the provided child augmenters to these channels
    and finally converts back to the original colorspace.

    The image array generated by this augmenter and provided to its children
    is in ``int16`` (**sic!** only augmenters that can handle ``int16`` arrays
    can be children!). The hue channel is mapped to the value
    range ``[0, 255]``. Before converting back to the source colorspace, the
    saturation channel's values are clipped to ``[0, 255]``. A modulo operation
    is applied to the hue channel's values, followed by a mapping from
    ``[0, 255]`` to ``[0, 180]`` (and finally the colorspace conversion).

    Parameters
    ----------
    from_colorspace : str, optional
        See `change_colorspace_()`.

    children : imgaug2.augmenters.meta.Augmenter or list of imgaug2.augmenters.meta.Augmenter or None, optional
        One or more augmenters to apply to converted images.
        They receive ``int16`` images with two channels (hue, saturation)
        and have to modify these.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.WithHueAndSaturation(
    >>>     iaa.WithChannels(0, iaa.Add((0, 50)))
    >>> )

    Create an augmenter that will add a random value between ``0`` and ``50``
    (uniformly sampled per image) hue channel in HSV colorspace. It
    automatically accounts for the hue being in angular representation, i.e.
    if the angle goes beyond 360 degrees, it will start again at 0 degrees.
    The colorspace is finally converted back to ``RGB`` (default setting).

    >>> aug = iaa.WithHueAndSaturation([
    >>>     iaa.WithChannels(0, iaa.Add((-30, 10))),
    >>>     iaa.WithChannels(1, [
    >>>         iaa.Multiply((0.5, 1.5)),
    >>>         iaa.LinearContrast((0.75, 1.25))
    >>>     ])
    >>> ])

    Create an augmenter that adds a random value sampled uniformly
    from the range ``[-30, 10]`` to the hue and multiplies the saturation
    by a random factor sampled uniformly from ``[0.5, 1.5]``. It also
    modifies the contrast of the saturation channel. After these steps,
    the ``HSV`` image is converted back to ``RGB``.

    """

    def __init__(
        self,
        children: ChildrenInput = None,
        from_colorspace: ColorSpace = "RGB",
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        super().__init__(
            seed=seed, name=name, random_state=random_state, deterministic=deterministic
        )

        self.children = meta.handle_children_list(children, self.name, "then")
        self.from_colorspace = from_colorspace

        # this dtype needs to be able to go beyond [0, 255] to e.g. accommodate
        # for Add or Multiply
        self._internal_dtype = np.int16

    @legacy(version="0.4.0")
    def _augment_batch_(
        self,
        batch: _BatchInAugmentation,
        random_state: iarandom.RNG,
        parents: list[meta.Augmenter],
        hooks: ia.HooksImages | None,
    ) -> _BatchInAugmentation:
        with batch.propagation_hooks_ctx(self, hooks, parents):
            images_hs, images_hsv = self._images_to_hsv_(batch.images)
            batch.images = images_hs

            batch = self.children.augment_batch_(batch, parents=parents + [self], hooks=hooks)

            batch.images = self._hs_to_images_(batch.images, images_hsv)

        return batch

    @legacy(version="0.4.0")
    def _images_to_hsv_(self, images: Images | None) -> tuple[Images | None, Images | None]:
        if images is None:
            return None, None

        # RGB (or other source colorspace) -> HSV
        images_hsv = change_colorspaces_(images, CSPACE_HSV, self.from_colorspace)

        # HSV -> HS
        images_hs = []
        for image_hsv in images_hsv:
            image_hsv = image_hsv.astype(np.int16)
            # project hue from [0,180] to [0,255] so that child augmenters
            # can assume the same value range for all channels
            hue = ((image_hsv[:, :, 0].astype(np.float32) / 180.0) * 255.0).astype(
                self._internal_dtype
            )
            saturation = image_hsv[:, :, 1]
            images_hs.append(np.stack([hue, saturation], axis=-1))
        if ia.is_np_array(images_hsv):
            images_hs = np.stack(images_hs, axis=0)
        return images_hs, images_hsv

    @legacy(version="0.4.0")
    def _hs_to_images_(self, images_hs: Images | None, images_hsv: Images | None) -> Images | None:
        if images_hs is None:
            return None
        # postprocess augmented HS int16 data
        # hue: modulo to [0, 255] then project to [0, 360/2]
        # saturation: clip to [0, 255]
        # + convert to uint8
        # + re-attach V channel to HS
        hue_and_sat_proj = []
        for i, hs_aug in enumerate(images_hs):
            hue_aug = hs_aug[:, :, 0]
            sat_aug = hs_aug[:, :, 1]
            hue_aug = ((np.mod(hue_aug, 255).astype(np.float32) / 255.0) * (360 / 2)).astype(
                np.uint8
            )
            sat_aug = iadt.clip_(sat_aug, 0, 255).astype(np.uint8)
            hue_and_sat_proj.append(np.stack([hue_aug, sat_aug, images_hsv[i][:, :, 2]], axis=-1))
        if ia.is_np_array(images_hs):
            hue_and_sat_proj = np.uint8(hue_and_sat_proj)

        # HSV -> RGB (or whatever the source colorspace was)
        images_rgb = change_colorspaces_(
            hue_and_sat_proj, to_colorspaces=self.from_colorspace, from_colorspaces=CSPACE_HSV
        )
        return images_rgb

    def _to_deterministic(self) -> meta.Augmenter:
        aug = self.copy()
        aug.children = aug.children.to_deterministic()
        aug.deterministic = True
        aug.random_state = self.random_state.derive_rng_()
        return aug

    def get_parameters(self) -> list[object]:
        """See `get_parameters()`."""
        return [self.from_colorspace]

    def get_children_lists(self) -> list[list[meta.Augmenter]]:
        """See `get_children_lists()`."""
        return cast(list[list[meta.Augmenter]], [self.children])

    def __str__(self) -> str:
        return (
            f"WithHueAndSaturation(from_colorspace={self.from_colorspace}, "
            f"name={self.name}, children=[{self.children}], deterministic={self.deterministic})"
        )

class MultiplyHueAndSaturation(WithHueAndSaturation):
    """
    Multiply hue and saturation by random values.

    The augmenter first transforms images to HSV colorspace, then multiplies
    the pixel values in the H and S channels and afterwards converts back to
    RGB.

    This augmenter is a wrapper around ``WithHueAndSaturation``.

    Parameters
    ----------
    mul : None or number or tuple of number or list of number or imgaug2.parameters.StochasticParameter, optional
        Multiplier with which to multiply all hue *and* saturation values of
        all pixels.
        It is expected to be in the range ``-10.0`` to ``+10.0``.
        Note that values of ``0.0`` or lower will remove all saturation.

            * If this is ``None``, `mul_hue` and/or `mul_saturation`
              may be set to values other than ``None``.

    mul_hue : None or number or tuple of number or list of number or imgaug2.parameters.StochasticParameter, optional
        Multiplier with which to multiply all hue values.
        This is expected to be in the range ``-10.0`` to ``+10.0`` and will
        automatically be projected to an angular representation using
        ``(hue/255) * (360/2)`` (OpenCV's hue representation is in the
        range ``[0, 180]`` instead of ``[0, 360]``).
        Only this or `mul` may be set, not both.

            * If this and `mul_saturation` are both ``None``, `mul` may
              be set to a non-``None`` value.

    mul_saturation : None or number or tuple of number or list of number or imgaug2.parameters.StochasticParameter, optional
        Multiplier with which to multiply all saturation values.
        It is expected to be in the range ``0.0`` to ``+10.0``.
        Only this or `mul` may be set, not both.

            * If this and `mul_hue` are both ``None``, `mul` may
              be set to a non-``None`` value.

    per_channel : bool or float, optional
        Whether to sample per image only one value from `mul` and use it for
        both hue and saturation (``False``) or to sample independently one
        value for hue and one for saturation (``True``).
        If this value is a float ``p``, then for ``p`` percent of all images
        `per_channel` will be treated as ``True``, otherwise as ``False``.

        This parameter has no effect if `mul_hue` and/or `mul_saturation`
        are used instead of `mul`.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.MultiplyHueAndSaturation((0.5, 1.5), per_channel=True)

    Multiply hue and saturation by random values between ``0.5`` and ``1.5``
    (independently per channel and the same value for all pixels within
    that channel). The hue will be automatically projected to an angular
    representation.

    >>> aug = iaa.MultiplyHueAndSaturation(mul_hue=(0.5, 1.5))

    Multiply only the hue by random values between ``0.5`` and ``1.5``.

    >>> aug = iaa.MultiplyHueAndSaturation(mul_saturation=(0.5, 1.5))

    Multiply only the saturation by random values between ``0.5`` and ``1.5``.

    """

    def __init__(
        self,
        mul: ParamInput | None = None,
        mul_hue: ParamInput | None = None,
        mul_saturation: ParamInput | None = None,
        per_channel: PerChannelInput = False,
        from_colorspace: ColorSpace = "RGB",
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        if mul is None and mul_hue is None and mul_saturation is None:
            mul_hue = (0.5, 1.5)
            mul_saturation = (0.0, 1.7)

        if mul is not None:
            assert mul_hue is None, (
                "`mul_hue` may not be set if `mul` is set. "
                f"It is set to: {str(mul_hue)} (type: {type(mul_hue)})."
            )
            assert mul_saturation is None, (
                "`mul_saturation` may not be set if `mul` is set. "
                f"It is set to: {str(mul_saturation)} (type: {type(mul_saturation)})."
            )
            mul = iap.handle_continuous_param(
                mul, "mul", value_range=(-10.0, 10.0), tuple_to_uniform=True, list_to_choice=True
            )
        else:
            if mul_hue is not None:
                mul_hue = iap.handle_continuous_param(
                    mul_hue,
                    "mul_hue",
                    value_range=(-10.0, 10.0),
                    tuple_to_uniform=True,
                    list_to_choice=True,
                )
            if mul_saturation is not None:
                mul_saturation = iap.handle_continuous_param(
                    mul_saturation,
                    "mul_saturation",
                    value_range=(0.0, 10.0),
                    tuple_to_uniform=True,
                    list_to_choice=True,
                )

        if random_state != "deprecated":
            seed = random_state
            random_state = "deprecated"

        if seed is None:
            rss = [None] * 5
        else:
            rss = iarandom.RNG.create_if_not_rng_(seed).derive_rngs_(5)

        # Store parameters for MLX fast-path
        self.mul = mul
        self.mul_hue = mul_hue
        self.mul_saturation = mul_saturation
        self.per_channel = iap.handle_probability_param(per_channel, "per_channel")

        arithmetic_lib = _get_arithmetic()
        children = []
        if mul is not None:
            children.append(
                arithmetic_lib.Multiply(
                    mul,
                    per_channel=per_channel,
                    seed=rss[0],
                    name=f"{name}-Multiply",
                    random_state=random_state,
                    deterministic=deterministic,
                )
            )
        else:
            if mul_hue is not None:
                children.append(
                    meta.WithChannels(
                        0,
                        arithmetic_lib.Multiply(
                            mul_hue,
                            seed=rss[0],
                            name=f"{name}-MultiplyHue",
                            random_state=random_state,
                            deterministic=deterministic,
                        ),
                        seed=rss[1],
                        name=f"{name}-WithChannelsHue",
                        random_state=random_state,
                        deterministic=deterministic,
                    )
                )
            if mul_saturation is not None:
                children.append(
                    meta.WithChannels(
                        1,
                        arithmetic_lib.Multiply(
                            mul_saturation,
                            seed=rss[2],
                            name=f"{name}-MultiplySaturation",
                            random_state=random_state,
                            deterministic=deterministic,
                        ),
                        seed=rss[3],
                        name=f"{name}-WithChannelsSaturation",
                        random_state=random_state,
                        deterministic=deterministic,
                    )
                )

        super().__init__(
            children,
            from_colorspace=from_colorspace,
            seed=rss[4],
            name=name,
            random_state=random_state,
            deterministic=deterministic,
        )

    @legacy(version="0.4.0")
    def _augment_batch_(
        self,
        batch: _BatchInAugmentation,
        random_state: iarandom.RNG,
        parents: list[meta.Augmenter],
        hooks: ia.HooksImages | None,
    ) -> _BatchInAugmentation:
        if batch.images is None:
            return batch

        images = batch.images

        # MLX fast-path
        if is_mlx_array(images):
            from imgaug2.mlx._core import mx, to_mlx

            images_mlx = images
            nb_images = len(images_mlx)

            # RGB -> HSV
            images_hsv = mlx_color.rgb_to_hsv(images_mlx)

            h = images_hsv[..., 0]
            s = images_hsv[..., 1]
            v = images_hsv[..., 2]

            rss = random_state.duplicate(3)

            # Apply mul (affects both H and S)
            if self.mul is not None:
                # Per-channel handling
                # If per_channel is True, we sample ONE value for H and ONE for S per image.
                # If False, one value for both.
                # But MultiplyHueAndSaturation init logic for children:
                # Multiply(mul, per_channel=per_channel)
                # Multiply with per_channel=True on 2-channel image (HS) samples 2 values per image.

                # We need to replicate Multiply's sampling.
                # Multiply(mul) logic:
                # samples = self.mul.draw_samples((nb_images, nb_channels))
                # For HS image, nb_channels=2.

                # Check per_channel param
                # But MultiplyHueAndSaturation doesn't store per_channel!
                # It passes it to child Multiply.
                # I need to store per_channel in __init__ too if I want to support it accurately.
                # However, looking at __init__, it receives per_channel.
                # I better modify __init__ to store per_channel as well.
                # Assuming I added self.per_channel = iap.handle_probability_param(per_channel, "per_channel")
                # Wait, I didn't add it yet. I need to add it in the first chunk.

                # For now, let's assume I added it.
                # Actually, standard MultiplyHueAndSaturation doesn't store it.
                # I will add self.per_channel storage in __init__.

                p_channel = self.per_channel.draw_samples((nb_images,), random_state=rss[0])
                samples = self.mul.draw_samples((nb_images, 2), random_state=rss[1])  # (N, 2)

                # If not per_channel, use first sample for both?
                # Multiply logic: if p > 0.5: use samples[i, :] (different)
                # else: use samples[i, 0] broadcasted.

                # Vectorized:
                # mask = p_channel > 0.5 (N,)
                # final_samples (N, 2)
                # final_samples[mask] = samples[mask]
                # final_samples[~mask] = samples[~mask, 0:1] (broadcast)

                p_mask = to_mlx(p_channel > 0.5).reshape(-1, 1)
                samples_mlx = to_mlx(samples)

                # Use scalar from col 0 for non-per-channel
                samples_scalar = samples_mlx[:, 0:1]

                final_samples = mx.where(p_mask, samples_mlx, samples_scalar)  # (N, 2)

                scales_h = final_samples[:, 0].reshape(-1, 1, 1)
                scales_s = final_samples[:, 1].reshape(-1, 1, 1)

                h = h * scales_h
                s = s * scales_s

            # Apply mul_hue
            if self.mul_hue is not None:
                scales_h = to_mlx(
                    self.mul_hue.draw_samples((nb_images,), random_state=rss[0])
                ).reshape(-1, 1, 1)
                h = h * scales_h

            # Apply mul_saturation
            if self.mul_saturation is not None:
                scales_s = to_mlx(
                    self.mul_saturation.draw_samples((nb_images,), random_state=rss[1])
                ).reshape(-1, 1, 1)
                s = s * scales_s

            # Clip/Modulo
            h = h % 360.0
            s = mx.clip(s, 0.0, 1.0)

            # Reconstruct
            images_hsv_aug = mx.stack([h, s, v], axis=-1)
            batch.images = mlx_color.hsv_to_rgb(images_hsv_aug)

            return batch

        if _is_mlx_list(images):
            from imgaug2.mlx._core import mx

            images_list = list(images)
            nb_images = len(images_list)
            rss = random_state.duplicate(3)

            if self.mul is not None:
                p_channel = self.per_channel.draw_samples((nb_images,), random_state=rss[0])
                samples = self.mul.draw_samples((nb_images, 2), random_state=rss[1])
            else:
                p_channel = None
                samples = None

            mul_hue = (
                self.mul_hue.draw_samples((nb_images,), random_state=rss[0])
                if self.mul_hue is not None
                else None
            )
            mul_saturation = (
                self.mul_saturation.draw_samples((nb_images,), random_state=rss[1])
                if self.mul_saturation is not None
                else None
            )

            for i, image in enumerate(images_list):
                images_hsv = mlx_color.rgb_to_hsv(image)
                h = images_hsv[..., 0]
                s = images_hsv[..., 1]
                v = images_hsv[..., 2]

                if self.mul is not None and p_channel is not None and samples is not None:
                    if p_channel[i] > 0.5:
                        scale_h = samples[i, 0]
                        scale_s = samples[i, 1]
                    else:
                        scale_h = samples[i, 0]
                        scale_s = samples[i, 0]
                    h = h * float(scale_h)
                    s = s * float(scale_s)

                if mul_hue is not None:
                    h = h * float(mul_hue[i])
                if mul_saturation is not None:
                    s = s * float(mul_saturation[i])

                h = h % 360.0
                s = mx.clip(s, 0.0, 1.0)

                images_hsv_aug = mx.stack([h, s, v], axis=-1)
                images_list[i] = mlx_color.hsv_to_rgb(images_hsv_aug)

            batch.images = images_list
            return batch

        return super()._augment_batch_(batch, random_state, parents, hooks)

class MultiplyHue(MultiplyHueAndSaturation):
    """
    Multiply the hue of images by random values.

    The augmenter first transforms images to HSV colorspace, then multiplies
    the pixel values in the H channel and afterwards converts back to
    RGB.

    This augmenter is a shortcut for ``MultiplyHueAndSaturation(mul_hue=...)``.

    Parameters
    ----------
    mul : number or tuple of number or list of number or imgaug2.parameters.StochasticParameter, optional
        Multiplier with which to multiply all hue values.
        This is expected to be in the range ``-10.0`` to ``+10.0`` and will
        automatically be projected to an angular representation using
        ``(hue/255) * (360/2)`` (OpenCV's hue representation is in the
        range ``[0, 180]`` instead of ``[0, 360]``).
        Only this or `mul` may be set, not both.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.MultiplyHue((0.5, 1.5))

    Multiply the hue channel of images using random values between ``0.5``
    and ``1.5``.

    """

    def __init__(
        self,
        mul: ParamInput = (-3.0, 3.0),
        from_colorspace: ColorSpace = "RGB",
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        super().__init__(
            mul_hue=mul,
            from_colorspace=from_colorspace,
            seed=seed,
            name=name,
            random_state=random_state,
            deterministic=deterministic,
        )

class MultiplySaturation(MultiplyHueAndSaturation):
    """
    Multiply the saturation of images by random values.

    The augmenter first transforms images to HSV colorspace, then multiplies
    the pixel values in the H channel and afterwards converts back to
    RGB.

    This augmenter is a shortcut for
    ``MultiplyHueAndSaturation(mul_saturation=...)``.

    Parameters
    ----------
    mul : number or tuple of number or list of number or imgaug2.parameters.StochasticParameter, optional
        Multiplier with which to multiply all saturation values.
        It is expected to be in the range ``0.0`` to ``+10.0``.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.MultiplySaturation((0.5, 1.5))

    Multiply the saturation channel of images using random values between
    ``0.5`` and ``1.5``.

    """

    def __init__(
        self,
        mul: ParamInput = (0.0, 3.0),
        from_colorspace: ColorSpace = "RGB",
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        super().__init__(
            mul_saturation=mul,
            from_colorspace=from_colorspace,
            seed=seed,
            name=name,
            random_state=random_state,
            deterministic=deterministic,
        )

@legacy(version="0.4.0")
class RemoveSaturation(MultiplySaturation):
    """Decrease the saturation of images by varying degrees.

    This creates images looking similar to `Grayscale`.

    This augmenter is the same as ``MultiplySaturation((0.0, 1.0))``.

    Parameters
    ----------
    mul : number or tuple of number or list of number or imgaug2.parameters.StochasticParameter, optional
        *Inverse* multiplier to use for the saturation values.
        High values denote stronger color removal. E.g. ``1.0`` will remove
        all saturation, ``0.0`` will remove nothing.
        Expected value range is ``[0.0, 1.0]``.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.RemoveSaturation((0.0, 1.0))

    Create an augmenter that decreases saturation by varying degrees.

    >>> aug = iaa.RemoveSaturation(1.0)

    Create an augmenter that removes all saturation from input images.
    This is similar to `Grayscale`.

    >>> aug = iaa.RemoveSaturation(from_colorspace=iaa.CSPACE_BGR)

    Create an augmenter that decreases saturation of images in ``BGR``
    colorspace by varying degrees.

    """

    @legacy(version="0.4.0")
    def __init__(
        self,
        mul: ParamInput = 1,
        from_colorspace: ColorSpace = CSPACE_RGB,
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        mul = iap.Subtract(
            1.0,
            iap.handle_continuous_param(
                mul, "mul", value_range=(0.0, 1.0), tuple_to_uniform=True, list_to_choice=True
            ),
            elementwise=True,
        )
        super().__init__(
            mul,
            from_colorspace=from_colorspace,
            seed=seed,
            name=name,
            random_state=random_state,
            deterministic=deterministic,
        )

# TODO removed deterministic and random_state here as parameters, because this
# function creates multiple child augmenters. not sure if this is sensible
# (give them all the same random state instead?)
# TODO this is for now deactivated, because HSV images returned by opencv have
#      value range 0-180 for the hue channel
#      and are supposed to be angular representations, i.e. if values go below
#      0 or above 180 they are supposed to overflow
#      to 180 and 0
"""
def AddToHueAndSaturation(value=0, per_channel=False, from_colorspace="RGB",
                          channels=[0, 1], name=None):
    ""
    Augmenter that transforms images into HSV space, selects the H and S
    channels and then adds a given range of values to these.

    Parameters
    ----------
    value : int or tuple of int or list of int or imgaug2.parameters.StochasticParameter, optional
        See `__init__()()`.

    per_channel : bool or float, optional
        See `__init__()()`.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    channels : int or list of int or None, optional
        See `__init__()()`.

    name : None or str, optional
        See `__init__()`.

    Examples
    --------
    >>> aug = AddToHueAndSaturation((-20, 20), per_channel=True)

    Adds random values between -20 and 20 to the hue and saturation
    (independently per channel and the same value for all pixels within
    that channel).

    ""
    if name is None:
        name = "Unnamed%s" % (ia.caller_name(),)

    return WithColorspace(
        to_colorspace="HSV",
        from_colorspace=from_colorspace,
        children=meta.WithChannels(
            channels=channels,
            children=arithmetic.Add(value=value, per_channel=per_channel)
        ),
        name=name
    )
"""

class AddToHueAndSaturation(meta.Augmenter):
    """
    Increases or decreases hue and saturation by random values.

    The augmenter first transforms images to HSV colorspace, then adds random
    values to the H and S channels and afterwards converts back to RGB.

    This augmenter is faster than using ``WithHueAndSaturation`` in combination
    with ``Add``.

    TODO add float support

    Parameters
    ----------
    value : None or int or tuple of int or list of int or imgaug2.parameters.StochasticParameter, optional
        Value to add to the hue *and* saturation of all pixels.
        It is expected to be in the range ``-255`` to ``+255``.

            * If this is ``None``, `value_hue` and/or `value_saturation`
              may be set to values other than ``None``.

    value_hue : None or int or tuple of int or list of int or imgaug2.parameters.StochasticParameter, optional
        Value to add to the hue of all pixels.
        This is expected to be in the range ``-255`` to ``+255`` and will
        automatically be projected to an angular representation using
        ``(hue/255) * (360/2)`` (OpenCV's hue representation is in the
        range ``[0, 180]`` instead of ``[0, 360]``).
        Only this or `value` may be set, not both.

            * If this and `value_saturation` are both ``None``, `value` may
              be set to a non-``None`` value.

    value_saturation : None or int or tuple of int or list of int or imgaug2.parameters.StochasticParameter, optional
        Value to add to the saturation of all pixels.
        It is expected to be in the range ``-255`` to ``+255``.
        Only this or `value` may be set, not both.

            * If this and `value_hue` are both ``None``, `value` may
              be set to a non-``None`` value.

    per_channel : bool or float, optional
        Whether to sample per image only one value from `value` and use it for
        both hue and saturation (``False``) or to sample independently one
        value for hue and one for saturation (``True``).
        If this value is a float ``p``, then for ``p`` percent of all images
        `per_channel` will be treated as ``True``, otherwise as ``False``.

        This parameter has no effect if `value_hue` and/or `value_saturation`
        are used instead of `value`.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.AddToHueAndSaturation((-50, 50), per_channel=True)

    Add random values between ``-50`` and ``50`` to the hue and saturation
    (independently per channel and the same value for all pixels within
    that channel).

    """

    _LUT_CACHE = None

    def __init__(
        self,
        value: ParamInput | None = None,
        value_hue: ParamInput | None = None,
        value_saturation: ParamInput | None = None,
        per_channel: PerChannelInput = False,
        from_colorspace: ColorSpace = "RGB",
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        super().__init__(
            seed=seed, name=name, random_state=random_state, deterministic=deterministic
        )
        if value is None and value_hue is None and value_saturation is None:
            value_hue = (-40, 40)
            value_saturation = (-40, 40)

        self.value = self._handle_value_arg(value, value_hue, value_saturation)
        self.value_hue = self._handle_value_hue_arg(value_hue)
        self.value_saturation = self._handle_value_saturation_arg(value_saturation)
        self.per_channel = iap.handle_probability_param(per_channel, "per_channel")
        self.from_colorspace = from_colorspace
        self.backend = "cv2"

        # precompute tables for cv2.LUT
        if self.backend == "cv2" and AddToHueAndSaturation._LUT_CACHE is None:
            AddToHueAndSaturation._LUT_CACHE = self._generate_lut_table()

    def _draw_samples(
        self, augmentables: Images, random_state: iarandom.RNG
    ) -> tuple[Array, Array]:
        nb_images = len(augmentables)
        rss = random_state.duplicate(2)

        if self.value is not None:
            per_channel = self.per_channel.draw_samples((nb_images,), random_state=rss[0])
            per_channel = per_channel > 0.5

            samples = self.value.draw_samples((nb_images, 2), random_state=rss[1]).astype(np.int32)
            assert -255 <= samples[0, 0] <= 255, (
                "Expected values sampled from `value` in "
                "AddToHueAndSaturation to be in range [-255, 255], "
                f"but got {samples[0, 0]:.8f}."
            )

            samples_hue = samples[:, 0]
            samples_saturation = np.copy(samples[:, 0])
            samples_saturation[per_channel] = samples[per_channel, 1]
        else:
            if self.value_hue is not None:
                samples_hue = self.value_hue.draw_samples((nb_images,), random_state=rss[0]).astype(
                    np.int32
                )
            else:
                samples_hue = np.zeros((nb_images,), dtype=np.int32)

            if self.value_saturation is not None:
                samples_saturation = self.value_saturation.draw_samples(
                    (nb_images,), random_state=rss[1]
                ).astype(np.int32)
            else:
                samples_saturation = np.zeros((nb_images,), dtype=np.int32)

        # project hue to angular representation
        # OpenCV uses range [0, 180] for the hue
        samples_hue = ((samples_hue.astype(np.float32) / 255.0) * (360 / 2)).astype(np.int32)

        return samples_hue, samples_saturation

    @legacy(version="0.4.0")
    def _augment_batch_(
        self,
        batch: _BatchInAugmentation,
        random_state: iarandom.RNG,
        parents: list[meta.Augmenter],
        hooks: ia.HooksImages | None,
    ) -> _BatchInAugmentation:
        if batch.images is None:
            return batch

        images = batch.images

        # MLX fast-path
        if is_mlx_array(images):
            from imgaug2.mlx._core import mx, to_mlx

            images_mlx = images
            # RGB -> HSV
            images_hsv = mlx_color.rgb_to_hsv(images_mlx)

            samples = self._draw_samples(batch.images, random_state)
            hues_shift = samples[0]  # (N,) int32
            sats_shift = samples[1]  # (N,) int32

            # Convert to MLX and floats
            hues_shift_mlx = to_mlx(hues_shift).reshape(-1, 1, 1).astype(mx.float32)
            sats_shift_mlx = to_mlx(sats_shift).reshape(-1, 1, 1).astype(mx.float32)

            # H: samples are 0-180 scale. 1 unit = 2 deg.
            # MLX H is 0-360.
            # So we add hues_shift * 2.0.
            hues_shift_deg = hues_shift_mlx * 2.0

            # S: samples are 0-255 scale.
            # MLX S is 0-1.
            # So we add sats_shift / 255.0.
            sats_shift_norm = sats_shift_mlx / 255.0

            h = images_hsv[..., 0]
            s = images_hsv[..., 1]
            v = images_hsv[..., 2]

            h = (h + hues_shift_deg) % 360.0
            s = mx.clip(s + sats_shift_norm, 0.0, 1.0)

            images_hsv_aug = mx.stack([h, s, v], axis=-1)
            batch.images = mlx_color.hsv_to_rgb(images_hsv_aug)
            return batch

        if _is_mlx_list(images):
            from imgaug2.mlx._core import mx

            images_list = list(images)
            samples = self._draw_samples(images_list, random_state)
            hues_shift = samples[0]
            sats_shift = samples[1]

            for i, image in enumerate(images_list):
                images_hsv = mlx_color.rgb_to_hsv(image)
                h = images_hsv[..., 0]
                s = images_hsv[..., 1]
                v = images_hsv[..., 2]

                h = (h + float(hues_shift[i]) * 2.0) % 360.0
                s = mx.clip(s + float(sats_shift[i]) / 255.0, 0.0, 1.0)

                images_hsv_aug = mx.stack([h, s, v], axis=-1)
                images_list[i] = mlx_color.hsv_to_rgb(images_hsv_aug)

            batch.images = images_list
            return batch

        input_dtypes = iadt.copy_dtypes_for_restore(images, force_list=True)

        # surprisingly, placing this here seems to be slightly slower than
        # placing it inside the loop
        # if isinstance(images_hsv, list):
        #    images_hsv = [img.astype(np.int32) for img in images_hsv]
        # else:
        #    images_hsv = images_hsv.astype(np.int32)

        images_hsv = change_colorspaces_(images, CSPACE_HSV, self.from_colorspace)
        samples = self._draw_samples(images, random_state)
        hues = samples[0]
        saturations = samples[1]

        # this is needed if no cache for LUT is used:
        # value_range = np.arange(0, 256, dtype=np.int16)

        gen = enumerate(zip(images_hsv, hues, saturations, strict=True))
        for i, (image_hsv, hue_i, saturation_i) in gen:
            if image_hsv.size == 0:
                continue

            if self.backend == "cv2":
                image_hsv = self._transform_image_cv2(image_hsv, hue_i, saturation_i)
            else:
                image_hsv = self._transform_image_numpy(image_hsv, hue_i, saturation_i)

            image_hsv = image_hsv.astype(input_dtypes[i])
            image_rgb = change_colorspace_(
                image_hsv, to_colorspace=self.from_colorspace, from_colorspace=CSPACE_HSV
            )
            batch.images[i] = image_rgb

        return batch

    @classmethod
    def _transform_image_cv2(cls, image_hsv: Array, hue: int, saturation: int) -> Array:
        # this has roughly the same speed as the numpy backend
        # for 64x64 and is about 25% faster for 224x224

        # code without using cache:
        # table_hue = np.mod(value_range + sample_hue, 180)
        # table_saturation = np.clip(value_range + sample_saturation, 0, 255)

        # table_hue = table_hue.astype(np.uint8, copy=False)
        # table_saturation = table_saturation.astype(np.uint8, copy=False)

        # image_hsv[..., 0] = cv2.LUT(image_hsv[..., 0], table_hue)
        # image_hsv[..., 1] = cv2.LUT(image_hsv[..., 1], table_saturation)

        # code with using cache (at best maybe 10% faster for 64x64):
        table_hue = cls._LUT_CACHE[0]
        table_saturation = cls._LUT_CACHE[1]
        tables = [table_hue[255 + int(hue)], table_saturation[255 + int(saturation)]]

        image_hsv[..., [0, 1]] = ia.apply_lut(image_hsv[..., [0, 1]], tables)

        return image_hsv

    @classmethod
    def _transform_image_numpy(cls, image_hsv: Array, hue: int, saturation: int) -> Array:
        # int16 seems to be slightly faster than int32
        image_hsv = image_hsv.astype(np.int16)
        # np.mod() works also as required here for negative values
        image_hsv[..., 0] = np.mod(image_hsv[..., 0] + hue, 180)
        image_hsv[..., 1] = np.clip(image_hsv[..., 1] + saturation, 0, 255)
        return image_hsv

    def get_parameters(self) -> list[object]:
        """See `get_parameters()`."""
        return [
            self.value,
            self.value_hue,
            self.value_saturation,
            self.per_channel,
            self.from_colorspace,
        ]

    @classmethod
    def _handle_value_arg(
        cls,
        value: ParamInput | None,
        value_hue: ParamInput | None,
        value_saturation: ParamInput | None,
    ) -> iap.StochasticParameter | None:
        if value is not None:
            assert value_hue is None, (
                "`value_hue` may not be set if `value` is set. "
                f"It is set to: {str(value_hue)} (type: {type(value_hue)})."
            )
            assert value_saturation is None, (
                "`value_saturation` may not be set if `value` is set. "
                f"It is set to: {str(value_saturation)} (type: {type(value_saturation)})."
            )
            return iap.handle_discrete_param(
                value,
                "value",
                value_range=(-255, 255),
                tuple_to_uniform=True,
                list_to_choice=True,
                allow_floats=False,
            )

        return None

    @classmethod
    def _handle_value_hue_arg(cls, value_hue: ParamInput | None) -> iap.StochasticParameter | None:
        if value_hue is not None:
            # we don't have to verify here that value is None, as the
            # exclusivity was already ensured in _handle_value_arg()
            return iap.handle_discrete_param(
                value_hue,
                "value_hue",
                value_range=(-255, 255),
                tuple_to_uniform=True,
                list_to_choice=True,
                allow_floats=False,
            )

        return None

    @classmethod
    def _handle_value_saturation_arg(
        cls, value_saturation: ParamInput | None
    ) -> iap.StochasticParameter | None:
        if value_saturation is not None:
            # we don't have to verify here that value is None, as the
            # exclusivity was already ensured in _handle_value_arg()
            return iap.handle_discrete_param(
                value_saturation,
                "value_saturation",
                value_range=(-255, 255),
                tuple_to_uniform=True,
                list_to_choice=True,
                allow_floats=False,
            )
        return None

    @classmethod
    def _generate_lut_table(cls) -> tuple[Array, Array]:
        # TODO Changing the dtype here to int8 makes gen test for this method
        #      fail, but all other tests still succeed. How can this be?
        #      The dtype was verified to remain int8, having min & max at
        #      -128 & 127.
        dtype = np.uint8
        table = (np.zeros((256 * 2, 256), dtype=dtype), np.zeros((256 * 2, 256), dtype=dtype))
        value_range = np.arange(0, 256, dtype=np.int16)
        # this could be done slightly faster by vectorizing the loop
        for i in range(-255, 255 + 1):
            table_hue = np.mod(value_range + i, 180)
            table_saturation = np.clip(value_range + i, 0, 255)
            table[0][255 + i, :] = table_hue
            table[1][255 + i, :] = table_saturation
        return table

class AddToHue(AddToHueAndSaturation):
    """
    Add random values to the hue of images.

    The augmenter first transforms images to HSV colorspace, then adds random
    values to the H channel and afterwards converts back to RGB.

    If you want to change both the hue and the saturation, it is recommended
    to use ``AddToHueAndSaturation`` as otherwise the image will be
    converted twice to HSV and back to RGB.

    This augmenter is a shortcut for ``AddToHueAndSaturation(value_hue=...)``.

    Parameters
    ----------
    value : None or int or tuple of int or list of int or imgaug2.parameters.StochasticParameter, optional
        Value to add to the hue of all pixels.
        This is expected to be in the range ``-255`` to ``+255`` and will
        automatically be projected to an angular representation using
        ``(hue/255) * (360/2)`` (OpenCV's hue representation is in the
        range ``[0, 180]`` instead of ``[0, 360]``).

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.AddToHue((-50, 50))

    Sample random values from the discrete uniform range ``[-50..50]``,
    convert them to angular representation and add them to the hue, i.e.
    to the ``H`` channel in ``HSV`` colorspace.

    """

    def __init__(
        self,
        value: ParamInput = (-255, 255),
        from_colorspace: ColorSpace = CSPACE_RGB,
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        super().__init__(
            value_hue=value,
            from_colorspace=from_colorspace,
            seed=seed,
            name=name,
            random_state=random_state,
            deterministic=deterministic,
        )

class AddToSaturation(AddToHueAndSaturation):
    """
    Add random values to the saturation of images.

    The augmenter first transforms images to HSV colorspace, then adds random
    values to the S channel and afterwards converts back to RGB.

    If you want to change both the hue and the saturation, it is recommended
    to use ``AddToHueAndSaturation`` as otherwise the image will be
    converted twice to HSV and back to RGB.

    This augmenter is a shortcut for
    ``AddToHueAndSaturation(value_saturation=...)``.

    Parameters
    ----------
    value : None or int or tuple of int or list of int or imgaug2.parameters.StochasticParameter, optional
        Value to add to the saturation of all pixels.
        It is expected to be in the range ``-255`` to ``+255``.

    from_colorspace : str, optional
        See `change_colorspace_()`.

    seed : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        See `__init__()`.

    name : None or str, optional
        See `__init__()`.

    random_state : None or int or imgaug2.random.RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence, optional
        Old name for parameter `seed`.
        Its usage will not yet cause a deprecation warning,
        but it is still recommended to use `seed` now.
        Outdated since 0.4.0.

    deterministic : bool, optional
        Deprecated since 0.4.0.
        See method ``to_deterministic()`` for an alternative and for
        details about what the "deterministic mode" actually does.

    Examples
    --------
    >>> aug = iaa.AddToSaturation((-50, 50))

    Sample random values from the discrete uniform range ``[-50..50]``,
    and add them to the saturation, i.e. to the ``S`` channel in ``HSV``
    colorspace.

    """

    def __init__(
        self,
        value: ParamInput = (-75, 75),
        from_colorspace: ColorSpace = "RGB",
        seed: RNGInput = None,
        name: str | None = None,
        random_state: RNGInput | Literal["deprecated"] = "deprecated",
        deterministic: bool | Literal["deprecated"] = "deprecated",
    ) -> None:
        super().__init__(
            value_saturation=value,
            from_colorspace=from_colorspace,
            seed=seed,
            name=name,
            random_state=random_state,
            deterministic=deterministic,
        )
